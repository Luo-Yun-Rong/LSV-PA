## 2020 Fall Logic Synthesis and Verification - Programming Assignment 2

### Implementation
#### Used API
 * I used `Abc_NtkCreateCone` to extract a single PO's circuit. The parameter `fUseAllCis` is set to 0 to exclude the non-relevant PIs.
 * I used `Abc_NtkToDar` to convert the extracted cone into `Aig_Man_t *` .
 * I used `Cnf_Derive` to generate the clauses of "positive cofactor circuit" and `Cnf_DataWriteIntoSolver` to create a new SAT solver with these clauses. I used `Cnf_DataLift` to rename the variables so as to represent the clauses of "negative cofactor circuit" and use `sat_solver_addclause` to append these new clauses.
 * I used `sat_solver_addvar` to generate the variables that enables or disables pairwise PI-equivalence between the positive cofactor circuit and negative cofactor circuit.
 * I used `sat_solver_solve` to do incremental SAT solving.
 
#### Data Structure 
  * `vector<int> UnateVec`: I used a vector<int> of length = number of PIs in circuit to reprensent the unateness with respect to every Pi. There are four cases. I used 0 to represent both positive and negative unate, 1 to represent positvie unate, 2 to represent negative unate, and 3 to represent binate. Initially, every entry is set to 3. If i-th PI is positive unate after SAT solving, I do `UnateVec[i] &=1`. Similary, if it is negative unate, I do `UnateVec[i] &=2`. Therefore, if i-th PI is both positive and negative unate, `UnateVec[i] =0` eventually. Similary, if some PI is neither positive unate nor negative unate, it remains 3.
   
  * `vector<int> posCofPiVars`: I used a vector<int> of length = number of PIs to bookeep the variable number of PIs in the positive cofactor circuit in CNF. Since Both `Abc_NtkCreateCone` and `Abc_NtkToDar` creates PI by the order of `Abc_NtkForEachPi`, the order of PI is not changed. Therefore, instead of constructing a mapping of PI between the original circuit and the PO cone, I only do a linear search a use `Abc_ObjName` to pair each PI. That is, `posCofPiVars[i]= var of i-th PI in original circuit` and `posCofPiVars[i]=NOTUSED` flag if the PI is not in the cone of current PO. I didn't keep track of the variable number of PIs in the negative cofactor. I only record an integer `VarShift` between the positive and negative cofactor circuit. 
 
  * `vector<int> ForceEqVars`: I used a vector<int> of length = number of PIs to bookeep the number of the variables that enables or disables PI-equivalence.
  * `lit * assumpList`: I used an array to store the assumption literals that will be pushed into SAT solver.
 
